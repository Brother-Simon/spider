use :node;

var Node = require('../Node').Node;

func ReturnStatement(argument)
  extends Node {
  
  this.type = 'ReturnStatement';
  this.argument = argument;
  
  if this.argument? {
    this.argument.parent = this;
  }
}

ReturnStatement.prototype.codegen = () -> {
  if !super.codegen() {
    return;
  }
  
  if this.argument? {
    this.argument = this.argument.codegen();
  }

  var parent = this.parent;
  while parent? and parent.type != "ForInStatement" and parent.type != "ForOfStatement" {
    parent = parent.parent;
  }

  if parent? {
    var context = this.getContext();
    var forContext = parent.getContext();

    if (!ReturnStatement.returnValueIndex?) { 
      ReturnStatement.returnValueIndex = 0; 
    }

    var returnIndex = ReturnStatement.returnValueIndex++;
    var returnedId = {
      "type": "Identifier",
      "name": "returned" + returnIndex
    };

    var returnValueId = {
      "type": "Identifier",
      "name": "returnValue" + returnIndex
    };

    forContext.node.body.splice(forContext.position, 0, {
      "type": "VariableDeclaration",
      "codeGenerated": true,
      "declarations": [{
        "type": "VariableDeclarator",
        "id": returnedId,
        "init": {
          "type": "Literal",
          "value": false
        }
      }, {
        "type": "VariableDeclarator",
        "id": returnValueId,
        "init": null
      }],
      "kind": "let"
    });

    context.node.body.splice(context.position, 0, {
      "type": "ExpressionStatement",
      "codeGenerated": true,
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": returnedId,
        "right": {
          "type": "Literal",
          "value": true
        }
      }
    });

    if this.argument? {
      context.node.body.splice(context.position + 1, 0, {
        "type": "ExpressionStatement",
        "codeGenerated": true,
        "expression": {
          "type": "AssignmentExpression",
          "operator": "=",
          "left": returnValueId,
          "right": this.argument
        }
      });
    }

    this.type = "ReturnStatement";
    this.argument = {
      "type": "Literal",
      "value": false
    };

    if !parent.returnValueIfStatement? {
      forContext.node.body.splice(forContext.position + 2, 0,  {
        "type": "IfStatement",
        "codeGenerated": true,
        "test": returnedId,
        "consequent": {
          "type": "BlockStatement",
          "body": [{
            "type": "ReturnStatement",
            "argument": returnValueId
          }]
        },
        "alternate": null
      });  
      parent.returnValueIfStatement = true;
    }
  }

  return this;
};

ReturnStatement.resetVariableNames = () -> {
  this.returnValueIndex = 0;
};

exports.ReturnStatement = ReturnStatement;